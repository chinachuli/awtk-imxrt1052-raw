/**
  ******************************************************************
  * @file    bsp_lcd.c
  * @author  fire
  * @version V2.0
  * @date    2018-xx-xx
  * @brief   lcd应用函数接口
  ******************************************************************
  * @attention
  *
  * 实验平台:野火  i.MXRT1052开发板 
  * 论坛    :http://www.firebbs.cn
  * 淘宝    :https://fire-stm32.taobao.com
  *
  ******************************************************************
  */
#include "fsl_iomuxc.h"
#include "fsl_gpio.h"  
#include "fsl_elcdif.h" 
#include "fsl_clock.h"
#include "fsl_pxp.h"

	
#include "pad_config.h"  
#include "bsp_lcd.h" 

//awtk
#include "base/g2d.h"
#include "base/idle.h"
#include "base/timer.h"
#include "main_loop/main_loop_simple.h"
#include "tkc/mem.h"
#include "base/lcd.h"
#include "lcd/lcd_mem_bgr565.h"
#include "lcd/lcd_mem_rgba8888.h"
    

/*******************************************************************************
 * 变量
 ******************************************************************************/

/* 帧中断标志 */
volatile bool s_frameDone = false;

/* 帧数计数器，使能帧中断才有效 */
__IO uint32_t s_frame_count = 0;

/* 显存 */
AT_NONCACHEABLE_SECTION_ALIGN( pixel_t s_psBufferLcd[3][LCD_PIXEL_HEIGHT][LCD_PIXEL_WIDTH], FRAME_BUFFER_ALIGN);




/* 指向当前的显存，由于是地址，所以用32位变量 */
static uint32_t CurrentFrameBuffer = (uint32_t)s_psBufferLcd[0];

/*******************************************************************************
 * 宏
 ******************************************************************************/
/* 所有引脚均使用同样的PAD配置 */
#define LCD_PAD_CONFIG_DATA            (SRE_1_FAST_SLEW_RATE| \
                                        DSE_6_R0_6| \
                                        SPEED_3_MAX_200MHz| \
                                        ODE_0_OPEN_DRAIN_DISABLED| \
                                        PKE_1_PULL_KEEPER_ENABLED| \
                                        PUE_0_KEEPER_SELECTED| \
                                        PUS_0_100K_OHM_PULL_DOWN| \
                                        HYS_0_HYSTERESIS_DISABLED)   
    /* 配置说明 : */
    /* 转换速率: 转换速率快
        驱动强度: R0/6 
        带宽配置 : max(200MHz)
        开漏配置: 关闭 
        拉/保持器配置: 使能
        拉/保持器选择: 保持器
        上拉/下拉选择: 100K欧姆下拉(选择了保持器此配置无效)
        滞回器配置: 禁止 */
        
/*******************************************************************************
 * 声明
 ******************************************************************************/
static void LCD_IOMUXC_MUX_Config(void);
static void LCD_IOMUXC_PAD_Config(void);
static void LCD_ELCDIF_Config(void);


/**
* @brief  初始化LCD相关IOMUXC的MUX复用配置
* @param  无
* @retval 无
*/
static void LCD_IOMUXC_MUX_Config(void)
{
    /* 所有引脚均不开启SION功能 */
    /* 时序控制信号线 */
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_00_LCD_CLK, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_01_LCD_ENABLE, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_02_LCD_HSYNC, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_03_LCD_VSYNC, 0U);
  
    /* RGB565数据信号线，
     DATA0~DATA4:B3~B7
     DATA5~DATA10:G2~G7
     DATA11~DATA15:R3~R7 */
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_04_LCD_DATA00, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_05_LCD_DATA01, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_06_LCD_DATA02, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_07_LCD_DATA03, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_08_LCD_DATA04, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_09_LCD_DATA05, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_10_LCD_DATA06, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_11_LCD_DATA07, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_12_LCD_DATA08, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_13_LCD_DATA09, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_14_LCD_DATA10, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B0_15_LCD_DATA11, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_00_LCD_DATA12, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_01_LCD_DATA13, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_02_LCD_DATA14, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_03_LCD_DATA15, 0U); 

		/* 若使用24位数据信号线需要初始化其余数据信号线 */
#if LCD_BUS_24_BIT
		IOMUXC_SetPinMux(IOMUXC_GPIO_B1_04_LCD_DATA16, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_05_LCD_DATA17, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_06_LCD_DATA18, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_07_LCD_DATA19, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_08_LCD_DATA20, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_09_LCD_DATA21, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_10_LCD_DATA22, 0U);                                    
    IOMUXC_SetPinMux(IOMUXC_GPIO_B1_11_LCD_DATA23, 0U);                                    
#endif 
		
    /* LCD_BL背光控制信号线 */
    IOMUXC_SetPinMux(LCD_BL_IOMUXC, 0U); 
}


/**
* @brief  初始化LCD相关IOMUXC的PAD属性配置
* @param  无
* @retval 无
*/
static void LCD_IOMUXC_PAD_Config(void)
{  
    /* 所有引脚均使用同样的PAD配置 */
    /* 时序控制信号线 */
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_00_LCD_CLK,LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_01_LCD_ENABLE, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_02_LCD_HSYNC, LCD_PAD_CONFIG_DATA);  
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_03_LCD_VSYNC, LCD_PAD_CONFIG_DATA); 

    /* RGB565数据信号线，
     DATA0~DATA4:B3~B7
     DATA5~DATA10:G2~G7
     DATA11~DATA15:R3~R7 */
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_04_LCD_DATA00, LCD_PAD_CONFIG_DATA); 
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_05_LCD_DATA01, LCD_PAD_CONFIG_DATA); 
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_06_LCD_DATA02, LCD_PAD_CONFIG_DATA);  
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_07_LCD_DATA03, LCD_PAD_CONFIG_DATA); 
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_08_LCD_DATA04, LCD_PAD_CONFIG_DATA); 
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_09_LCD_DATA05, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_10_LCD_DATA06, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_11_LCD_DATA07, LCD_PAD_CONFIG_DATA);  
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_12_LCD_DATA08, LCD_PAD_CONFIG_DATA);  
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_13_LCD_DATA09, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_14_LCD_DATA10, LCD_PAD_CONFIG_DATA); 
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B0_15_LCD_DATA11, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_00_LCD_DATA12, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_01_LCD_DATA13, LCD_PAD_CONFIG_DATA);
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_02_LCD_DATA14, LCD_PAD_CONFIG_DATA); 
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_03_LCD_DATA15, LCD_PAD_CONFIG_DATA); 
		
		/* 若使用24位数据信号线需要初始化其余数据信号线 */
#if LCD_BUS_24_BIT
		IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_04_LCD_DATA16, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_05_LCD_DATA17, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_06_LCD_DATA18, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_07_LCD_DATA19, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_08_LCD_DATA20, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_09_LCD_DATA21, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_10_LCD_DATA22, LCD_PAD_CONFIG_DATA);                                    
    IOMUXC_SetPinConfig(IOMUXC_GPIO_B1_11_LCD_DATA23, LCD_PAD_CONFIG_DATA);                                    
#endif     
    /* LCD_BL背光控制信号线 */
    IOMUXC_SetPinConfig(LCD_BL_IOMUXC, LCD_PAD_CONFIG_DATA);
}

/**
* @brief  初始化ELCDIF外设
* @param  无
* @retval 无
*/
static void LCD_ELCDIF_Config(void)
{	
    const elcdif_rgb_mode_config_t config = {
        .panelWidth = LCD_PIXEL_WIDTH,
        .panelHeight = LCD_PIXEL_HEIGHT,
        .hsw = LCD_HSW,
        .hfp = LCD_HFP,
        .hbp = LCD_HBP,
        .vsw = LCD_VSW,
        .vfp = LCD_VFP,
        .vbp = LCD_VBP,
        .polarityFlags =  LCD_POLARITY_FLAGS,													
        .bufferAddr = (uint32_t)s_psBufferLcd[0],
        .pixelFormat = ELCDIF_PIXEL_FORMAT,
        .dataBus = LCD_DATA_BUS_WIDTH,
    };
 
  ELCDIF_RgbModeInit(LCDIF, &config);
  ELCDIF_RgbModeStart(LCDIF);
}



/**
* @brief  初始化ELCDIF使用的时钟
* @param  无
* @retval 无
*/
void LCD_InitClock(void)
{
    /*
     * 要把帧率设置成60Hz，所以像素时钟频率为:
     * 水平像素时钟个数：(LCD_IMG_WIDTH + LCD_HSW + LCD_HFP + LCD_HBP ) 
     * 垂直行数：(LCD_IMG_HEIGHT + LCD_VSW + LCD_VFP + LCD_VBP)
     * 
     * 像素时钟频率：(800 + 1 + 22 + 46) * (480 + 1 + 22 + 23) * 60 = 27.4M.
     * 本例子设置 LCDIF 像素时钟频率为 27M.
     *	 LCD的帧率以实测的为准。
     */

    /*
     * 初始化 Vedio PLL，即PLL5
     * Video PLL 输出频率为 
     * OSC24M * (loopDivider + (denominator / numerator)) / postDivider = 108MHz.
     */
    clock_video_pll_config_t config = {
        .loopDivider = 36, .postDivider = 8, .numerator = 0, .denominator = 0,
    };

    CLOCK_InitVideoPll(&config);

    /*
     * 000 derive clock from PLL2
     * 001 derive clock from PLL3 PFD3
     * 010 derive clock from PLL5
     * 011 derive clock from PLL2 PFD0
     * 100 derive clock from PLL2 PFD1
     * 101 derive clock from PLL3 PFD1
     */
    /* 选择为vedio PLL，即PLL5 */
    CLOCK_SetMux(kCLOCK_LcdifPreMux, 2);

    /* 设置预分频 */  
    CLOCK_SetDiv(kCLOCK_LcdifPreDiv, 1);

		/* 设置分频 */  
    CLOCK_SetDiv(kCLOCK_LcdifDiv, 1);
}

/**
* @brief  初始化背光引脚并点亮
* @param  无
* @retval 无
*/

/*
void LCD_BackLight_ON(void)
{    
    // 背光，高电平点亮 
    gpio_pin_config_t config = {
      kGPIO_DigitalOutput, 
      1,
      kGPIO_NoIntmode
    };

    GPIO_PinInit(LCD_BL_GPIO, LCD_BL_GPIO_PIN, &config);
}
*/


/**
* @brief  初始化液晶屏
* @param  enableInterrupt ：是否使能中断
*		@arg LCD_INTERRUPT_DISABLE 不使能
*		@arg LCD_INTERRUPT_ENABLE  使能
* @retval 无
*/
void fLCD_Init(bool enableInterrupt)
{
#if LCD_RGB_888	
	/* 
  * 本代码配置LCD read_qos 及 write_qos 寄存器，支持配置值的范围为0x0-0xF，
  * 此处设置qos为0xF最大值。
	*	Qos：
  * The Quality of Service (QoS) tidemark value represents the maximum
	*	permitted number of active transactions before the QoS mechanism is
	*	activated。
	*  详细说明见
	* 《IMXRT1050RM》（参考手册）的章节《Network Interconnect Bus System (NIC-301)》
	* 及《CoreLink  Network Interconnect (NIC-301)Technical Reference Manua r2p3》
	* @note 
  *  简单来说就是提高LCD使用RT1052内部总线的带宽数量、能力
	*  对于800*480@XRGB8888@60Hz的显示必须要这样配置，
  *  对于800*480@RGB565@60Hz的显示不需要配置，保持默认即可（推荐）
	*/
  
  *((uint32_t *)0x41044100) = 0x0000000f;
  *((uint32_t *)0x41044104) = 0x0000000f;
        
#endif
	
	/* 初始化eLCDIF引脚、时钟 、模式、背光以及中断*/
  LCD_IOMUXC_MUX_Config();
  LCD_IOMUXC_PAD_Config();
  LCD_InitClock();
  LCD_ELCDIF_Config();
  LCD_BackLight_ON();
  
  if(enableInterrupt)
  {
    LCD_InterruptConfig();
  }
  
}

/***************************中断相关******************************/
/**
* @brief  配置ELCDIF中断
* @param  无
* @retval 无
*/
void LCD_InterruptConfig(void)
{
  /* 使能中断 */
  EnableIRQ(LCDIF_IRQn);
   
  /* 配置ELCDIF为CurFrameDoneInterrupt中断 */
  ELCDIF_EnableInterrupts(LCDIF, kELCDIF_CurFrameDoneInterruptEnable);
  
}

static uint8_t* next_fb = NULL;
static uint8_t* online_fb = NULL;

//以下为AWTK中的移植
ret_t lcd_rt1052_begin_frame(lcd_t* lcd, rect_t* dirty_rect) {
  if (lcd_is_swappable(lcd)) {
    uint32_t i = 0;
    static uint32_t  countt;
    countt++;
    lcd_mem_t* mem = (lcd_mem_t*)lcd;

    mem->next_fb = NULL;		
    mem->online_fb = NULL;
    mem->offline_fb = NULL;
    
    
    for (i = 0; i < ARRAY_SIZE(s_psBufferLcd); i++) {
      uint8_t* iter = (uint8_t*)s_psBufferLcd[i];
      if (iter != online_fb && iter != next_fb) {
        mem->offline_fb = iter;
        break;
      }
    }
    
      s_frame_count++;
    
  }

  return RET_OK;
}

ret_t lcd_rt1052_swap(lcd_t* lcd) {
  lcd_mem_t* mem = (lcd_mem_t*)lcd;

  if(next_fb==NULL){
     next_fb = mem->offline_fb;
     ELCDIF_SetNextBufferAddr(LCDIF, (uint32_t)next_fb);
  }

  return RET_OK;
}


lcd_t* rt1052_create_lcd(wh_t w, wh_t h) {
  lcd_t* lcd = NULL;

#ifdef USE_THREE_FB
  lcd = lcd_mem_bgr565_create_three_fb(w, h, (uint8_t*)s_psBufferLcd[0], (uint8_t*)s_psBufferLcd[1], (uint8_t*)s_psBufferLcd[2] );
  lcd->swap = lcd_rt1052_swap;
  lcd->begin_frame = lcd_rt1052_begin_frame;
#else
  lcd = lcd_mem_bgr565_create_double_fb(w, h, (uint8_t*)s_psBufferLcd[0], (uint8_t*)s_psBufferLcd[1] );
#endif
  
  
  
  
  return lcd;
}

/**
* @brief  ELCDIF中断服务函数
* @param  无
* @retval 无---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
void LCDIF_IRQHandler(void)
{
    uint32_t intStatus;
static uint8_t* online_temp_fb = NULL;

    intStatus = ELCDIF_GetInterruptStatus(LCDIF);
    ELCDIF_ClearInterruptStatus(LCDIF, intStatus);
    
    if (intStatus & kELCDIF_CurFrameDone) {
      if (next_fb != NULL) {
        online_fb  = next_fb;
        next_fb = NULL;
      }
    }
    
    /* 以下部分是为 ARM 的勘误838869添加的, 该错误影响 Cortex-M4, Cortex-M4F内核， 立即存储覆盖重叠异常，导致返回操作可能会指向错误的中断 CM7不受影响，此处保留该代码 */  
#if defined __CORTEX_M && (__CORTEX_M == 4U)
    __DSB();
#endif
}